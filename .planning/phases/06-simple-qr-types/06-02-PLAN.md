---
phase: 06-simple-qr-types
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/formatters/wifi.ts
  - components/forms/qr-forms/WiFiForm.tsx
  - lib/formatters/index.ts
  - components/forms/qr-forms/index.ts
  - lib/registry.ts
  - components/TypeSelector.tsx
autonomous: true

must_haves:
  truths:
    - "User can enter network SSID"
    - "User can enter network password"
    - "User can select encryption type (WPA/WPA2, WEP, Open)"
    - "User can toggle hidden SSID option"
    - "System escapes special characters correctly"
    - "System generates WIFI:T:{type};S:{ssid};P:{pass};H:{hidden};; format"
  artifacts:
    - path: "lib/formatters/wifi.ts"
      provides: "WiFi schema with discriminated union and formatter"
      exports: ["wifiSchema", "WiFiData", "formatWiFi"]
    - path: "components/forms/qr-forms/WiFiForm.tsx"
      provides: "WiFi form component with conditional password"
      exports: ["WiFiForm"]
  key_links:
    - from: "WiFiForm.tsx"
      to: "wifi.ts"
      via: "zodResolver(wifiSchema)"
      pattern: "zodResolver.*wifiSchema"
    - from: "lib/registry.ts"
      to: "WiFiForm"
      via: "qrFormRegistry"
      pattern: "wifi:\\s*WiFiForm"
    - from: "lib/formatters/index.ts"
      to: "wifi.ts"
      via: "QR_TYPES constant"
      pattern: "'wifi'"
---

<objective>
Implement WiFi QR code type with discriminated union validation, special character escaping, and conditional password field.

Purpose: Enable users to create WiFi QR codes that work when scanned by iOS/Android cameras, handling encryption-specific validation and special character escaping.
Output: Working WiFi QR type selectable from TypeSelector, generating scannable WIFI: format strings.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-simple-qr-types/06-RESEARCH.md

# Existing patterns to follow
@lib/formatters/email.ts
@components/forms/qr-forms/EmailForm.tsx
@lib/formatters/index.ts
@lib/registry.ts
@components/TypeSelector.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WiFi Schema and Formatter</name>
  <files>lib/formatters/wifi.ts</files>
  <action>
Create `lib/formatters/wifi.ts` with discriminated union schema and escape function:

1. Define escape helper function (CRITICAL: backslash FIRST to avoid double-escaping):
```typescript
function escapeWiFiSpecialChars(text: string): string {
  return text
    .replace(/\\/g, '\\\\')  // Backslash FIRST
    .replace(/;/g, '\\;')
    .replace(/:/g, '\\:')
    .replace(/,/g, '\\,')
    .replace(/"/g, '\\"');
}
```

2. Define wifiSchema as Zod discriminatedUnion on 'encryption' field:

   **Open network (nopass):**
   - encryption: z.literal('nopass')
   - ssid: string, required, max 32 chars
   - hidden: boolean, default false
   - NO password field

   **WPA/WPA2:**
   - encryption: z.literal('WPA')
   - ssid: string, required, max 32 chars
   - password: string, min 8, max 63 chars
   - hidden: boolean, default false

   **WEP:**
   - encryption: z.literal('WEP')
   - ssid: string, required, max 32 chars
   - password: string, must be exactly 5 OR 13 chars (use .refine())
   - hidden: boolean, default false

   IMPORTANT: Do NOT apply .transform(escapeWiFiSpecialChars) in schema. Apply escaping in formatter function instead. This keeps raw values in form state for display.

3. Export WiFiData type (union of all three variants)

4. Implement formatWiFi(data: WiFiData): string:
   - Escape ssid: `escapeWiFiSpecialChars(data.ssid)`
   - Determine encryption type string: 'WPA', 'WEP', or '' for open
   - Get password (escaped) or empty string if open network
   - Get hidden flag: 'true' or '' (NOT 'false')
   - Return: `WIFI:T:${encType};S:${escapedSsid};P:${escapedPass};H:${hiddenFlag};;`

CRITICAL: Format MUST end with `;;` (double semicolon), not single semicolon.
CRITICAL: Hidden flag is 'true' or empty string, never 'false'.
  </action>
  <verify>
Create test file and run:
```typescript
import { wifiSchema, formatWiFi } from './wifi';

// Valid WPA
console.log(wifiSchema.safeParse({
  encryption: 'WPA', ssid: 'MyNetwork', password: 'password123', hidden: false
}).success); // true

// Valid Open
console.log(wifiSchema.safeParse({
  encryption: 'nopass', ssid: 'FreeWiFi', hidden: false
}).success); // true

// Valid WEP (5 chars)
console.log(wifiSchema.safeParse({
  encryption: 'WEP', ssid: 'OldRouter', password: '12345', hidden: false
}).success); // true

// Invalid WPA (password too short)
console.log(wifiSchema.safeParse({
  encryption: 'WPA', ssid: 'MyNetwork', password: 'short', hidden: false
}).success); // false

// Invalid WEP (wrong length)
console.log(wifiSchema.safeParse({
  encryption: 'WEP', ssid: 'OldRouter', password: '123456', hidden: false
}).success); // false (6 chars, must be 5 or 13)

// Format output
console.log(formatWiFi({ encryption: 'WPA', ssid: 'MyNetwork', password: 'Pass:123', hidden: false }));
// WIFI:T:WPA;S:MyNetwork;P:Pass\:123;H:;;

console.log(formatWiFi({ encryption: 'nopass', ssid: 'Open;Net', hidden: true }));
// WIFI:T:;S:Open\;Net;P:;H:true;;

// Special char escaping order
console.log(formatWiFi({ encryption: 'WPA', ssid: 'Net\\work', password: 'Pass\\;123', hidden: false }));
// WIFI:T:WPA;S:Net\\work;P:Pass\\\;123;H:;;
```
  </verify>
  <done>wifiSchema validates with discriminated union; formatWiFi escapes correctly (backslash first) and ends with ;;</done>
</task>

<task type="auto">
  <name>Task 2: Create WiFi Form Component</name>
  <files>components/forms/qr-forms/WiFiForm.tsx</files>
  <action>
Create `components/forms/qr-forms/WiFiForm.tsx` following EmailForm.tsx pattern but with conditional password field:

1. Import useForm, zodResolver, useEffect from react-hook-form
2. Import wifiSchema, WiFiData, formatWiFi from @/lib/formatters
3. Import FormFieldSet from '../FormFieldSet'

4. Props type:
```typescript
type Props = {
  onDataChange: (data: string) => void;
  initialValue?: { encryption?: string; ssid?: string; password?: string; hidden?: boolean };
};
```

5. useForm setup:
   - resolver: zodResolver(wifiSchema)
   - mode: 'onChange' (better UX for conditional fields)
   - defaultValues: encryption 'WPA', ssid '', password '', hidden false

6. Watch encryption field to show/hide password:
```typescript
const encryption = watch('encryption');
const needsPassword = encryption !== 'nopass';
```

7. Watch full form and update QR on valid changes:
   - Use watch() to get formData
   - Use wifiSchema.safeParse(formData)
   - If valid, call onDataChange(formatWiFi(result.data))
   - If invalid, call onDataChange('') to clear preview

8. Render form fields:
   - **SSID field** (always visible):
     - name="ssid"
     - label="Network Name (SSID)"
     - input type="text"
     - placeholder="MyHomeNetwork"
     - maxLength={32}

   - **Encryption selector**:
     - name="encryption"
     - label="Security Type"
     - select element with options:
       - value="WPA": "WPA/WPA2 (recommended)"
       - value="WEP": "WEP (legacy)"
       - value="nopass": "Open Network (no password)"

   - **Password field** (conditional: only when needsPassword):
     - name="password"
     - label="Password"
     - input type="password"
     - placeholder depends on encryption:
       - WPA: "Minimum 8 characters"
       - WEP: "Exactly 5 or 13 characters"
     - maxLength={63}

   - **Hidden network checkbox**:
     - name="hidden"
     - label="Hidden Network"
     - Checkbox with label text: "This is a hidden network"
     - Use field.value for checked state
     - onChange: field.onChange(e.target.checked)

IMPORTANT: When encryption changes from password-required to nopass, the password field value stays in form state but is ignored by schema. This is fine.

Use same Tailwind classes as EmailForm.tsx for consistency. For checkbox, use:
```typescript
<label className="flex items-center gap-2 cursor-pointer">
  <input
    type="checkbox"
    checked={field.value}
    onChange={(e) => field.onChange(e.target.checked)}
    className="w-4 h-4 rounded border-[var(--border-medium)]
      text-[var(--accent-start)] focus:ring-[var(--accent-start)]"
  />
  <span className="text-sm text-[var(--text-secondary)]">This is a hidden network</span>
</label>
```
  </action>
  <verify>
Run dev server: `npm run dev`
Navigate to app, verify WiFi option not yet visible (registry not updated)
Check file compiles without TypeScript errors: `npx tsc --noEmit`
  </verify>
  <done>WiFiForm component created with SSID, encryption selector, conditional password, and hidden toggle</done>
</task>

<task type="auto">
  <name>Task 3: Register WiFi Type in System</name>
  <files>
lib/formatters/index.ts
components/forms/qr-forms/index.ts
lib/registry.ts
components/TypeSelector.tsx
  </files>
  <action>
Update four files to register the WiFi type:

NOTE: If Plan 01 (WhatsApp) ran first, these files already have WhatsApp added. Merge carefully.

1. **lib/formatters/index.ts** - Add export and extend QR_TYPES:
```typescript
// WiFi type
export { wifiSchema, type WiFiData, formatWiFi } from './wifi';

// QR_TYPES should include wifi (and whatsapp if Plan 01 completed)
export const QR_TYPES = ['url', 'text', 'email', 'whatsapp', 'wifi'] as const;
// If whatsapp not yet added: ['url', 'text', 'email', 'wifi']
```

2. **components/forms/qr-forms/index.ts** - Add export:
```typescript
export { WiFiForm } from './WiFiForm';
```

3. **lib/registry.ts** - Add to registry:
- Import WiFiForm from @/components/forms/qr-forms/WiFiForm
- Add to qrFormRegistry: `wifi: WiFiForm`

4. **components/TypeSelector.tsx** - Add label:
- Add to typeLabels: `wifi: 'WiFi'`

Order in QR_TYPES: url, text, email, whatsapp, wifi (if both present)
  </action>
  <verify>
Run dev server: `npm run dev`
Navigate to app at localhost:3000
Verify: "WiFi" button appears in TypeSelector
Click WiFi: form shows SSID, Security Type, Password, Hidden Network fields
Test WPA flow:
  - Enter SSID "MyNetwork"
  - Leave Security Type as "WPA/WPA2"
  - Enter password "password123" (8+ chars)
  - QR preview updates
Test Open flow:
  - Change Security Type to "Open Network"
  - Password field disappears
  - QR preview updates (shows WIFI:T:;S:... format)
Test WEP flow:
  - Change Security Type to "WEP"
  - Enter 5-char password: validates
  - Enter 6-char password: shows error "must be exactly 5 or 13 characters"
Test special characters:
  - SSID "My;Network" generates escaped output "My\;Network"
  - Password "Pass:123" generates escaped output "Pass\:123"
Test hidden network:
  - Check "This is a hidden network"
  - QR format includes "H:true"
Scan QR with phone camera: should prompt to connect to WiFi network
  </verify>
  <done>WiFi type fully integrated - selectable in UI, form renders with conditional fields, QR generates valid WIFI: format</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit` passes
2. Dev server runs: `npm run dev` starts without errors
3. WiFi selectable in TypeSelector
4. WiFi form validates:
   - Empty SSID shows "Network name is required"
   - WPA with <8 char password shows error
   - WEP with wrong length (not 5 or 13) shows error
   - Open network accepts no password
5. Password field hides when "Open Network" selected
6. Hidden network checkbox toggles H:true in output
7. Special characters escaped correctly (test with semicolon, backslash)
8. QR format ends with ;; (double semicolon)
9. Generated QR scannable by iOS/Android camera
</verification>

<success_criteria>
- WIFI-01: User can enter network SSID - SSID field works with 32 char limit
- WIFI-02: User can enter network password - conditional password field works
- WIFI-03: User can select encryption type - dropdown with WPA/WEP/Open options
- WIFI-04: User can toggle hidden SSID - checkbox updates H: parameter
- WIFI-05: System escapes special characters - backslash-first escaping verified
- WIFI-06: System generates WIFI:T:{type};S:{ssid};P:{pass};H:{hidden};; format - double semicolon terminator verified
</success_criteria>

<output>
After completion, create `.planning/phases/06-simple-qr-types/06-02-SUMMARY.md`
</output>
