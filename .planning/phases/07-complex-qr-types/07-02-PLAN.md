---
phase: 07-complex-qr-types
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/formatters/telegram.ts
  - components/forms/qr-forms/TelegramForm.tsx
  - lib/formatters/index.ts
  - components/forms/qr-forms/index.ts
  - lib/registry.ts
  - components/TypeSelector.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can create Telegram QR in username mode with 5-32 character validation"
    - "User can create Telegram QR in phone mode with E.164 validation"
    - "User can create Telegram QR in bot mode with 'bot' suffix enforcement"
    - "Telegram username auto-strips @ symbol from input before validation"
    - "QR code generates correct t.me URL format for each mode"
  artifacts:
    - path: "lib/formatters/telegram.ts"
      provides: "Telegram discriminated union schema + t.me formatter"
      exports: ["telegramSchema", "TelegramData", "formatTelegram"]
    - path: "components/forms/qr-forms/TelegramForm.tsx"
      provides: "Mode selector + conditional fields form"
      min_lines: 60
  key_links:
    - from: "components/forms/qr-forms/TelegramForm.tsx"
      to: "lib/formatters/telegram.ts"
      via: "import telegramSchema, formatTelegram"
      pattern: "import.*from.*telegram"
    - from: "lib/registry.ts"
      to: "components/forms/qr-forms/TelegramForm.tsx"
      via: "qrFormRegistry entry"
      pattern: "telegram:.*TelegramForm"
---

<objective>
Implement Telegram QR code type with mode-based discriminated union (username/phone/bot) for generating t.me deep links.

Purpose: Enable users to create QR codes that open Telegram chats with specific users, phone contacts, or bots.
Output: TelegramForm component with mode selector, Telegram discriminated union schema+formatter, registered in QR type system.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-complex-qr-types/07-RESEARCH.md

# Established patterns from Phase 6
@lib/formatters/wifi.ts
@components/forms/qr-forms/WiFiForm.tsx
@lib/registry.ts
@lib/formatters/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Telegram Discriminated Union Schema + Formatter</name>
  <files>lib/formatters/telegram.ts</files>
  <action>
Create `lib/formatters/telegram.ts` following the WiFi discriminated union pattern:

1. **Import:**
   ```typescript
   import { z } from 'zod';
   ```

2. **Schema (telegramSchema) - Discriminated union on 'mode' field:**

   **Username mode:**
   ```typescript
   z.object({
     mode: z.literal('username'),
     username: z.string()
       .min(1, 'Username is required')
       .transform((val) => val.replace(/^@/, ''))  // Auto-strip @ prefix
       .pipe(
         z.string()
           .min(5, 'Username must be at least 5 characters')
           .max(32, 'Username must be 32 characters or less')
           .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores')
       ),
   }),
   ```

   **Phone mode (reuse WhatsApp E.164 pattern):**
   ```typescript
   z.object({
     mode: z.literal('phone'),
     phoneNumber: z.string()
       .min(1, 'Phone number is required')
       .regex(/^\+[1-9]\d{6,14}$/, 'Must be valid E.164 format (e.g., +12025550172)'),
   }),
   ```

   **Bot mode:**
   ```typescript
   z.object({
     mode: z.literal('bot'),
     botUsername: z.string()
       .min(1, 'Bot username is required')
       .transform((val) => val.replace(/^@/, ''))  // Auto-strip @ prefix
       .pipe(
         z.string()
           .min(5, 'Bot username must be at least 5 characters')
           .max(32, 'Bot username must be 32 characters or less')
           .regex(/^[a-zA-Z0-9_]+$/, 'Bot username can only contain letters, numbers, and underscores')
           .refine(
             (val) => val.toLowerCase().endsWith('bot') || val.toLowerCase().endsWith('_bot'),
             'Bot username must end with "bot" or "_bot"'
           )
       ),
   }),
   ```

3. **Type export:**
   ```typescript
   export type TelegramData = z.infer<typeof telegramSchema>;
   ```

4. **Formatter (formatTelegram):**
   ```typescript
   export function formatTelegram(data: TelegramData): string {
     switch (data.mode) {
       case 'username':
         // Username link: t.me/username
         return `https://t.me/${data.username}`;

       case 'phone':
         // Phone link: t.me/+1234567890 (includes + prefix)
         return `https://t.me/${data.phoneNumber}`;

       case 'bot':
         // Bot link: t.me/botusername
         return `https://t.me/${data.botUsername}`;
     }
   }
   ```

   **IMPORTANT:** Telegram phone links KEEP the + prefix (unlike WhatsApp wa.me which strips it). data.phoneNumber already includes +, so use it directly.
  </action>
  <verify>
   - `npx tsc --noEmit` passes
   - Test in Node REPL:
     ```
     const { telegramSchema, formatTelegram } = require('./lib/formatters/telegram');
     telegramSchema.safeParse({ mode: 'username', username: '@testuser' }); // Should succeed, username transformed to 'testuser'
     formatTelegram({ mode: 'username', username: 'testuser' }); // Returns 'https://t.me/testuser'
     formatTelegram({ mode: 'phone', phoneNumber: '+12025550172' }); // Returns 'https://t.me/+12025550172'
     ```
  </verify>
  <done>telegramSchema validates three modes with mode-specific rules, formatTelegram generates correct t.me URLs, @ auto-stripping works via transform</done>
</task>

<task type="auto">
  <name>Task 2: Create TelegramForm Component with Mode Selector</name>
  <files>components/forms/qr-forms/TelegramForm.tsx</files>
  <action>
Create `components/forms/qr-forms/TelegramForm.tsx` following WiFiForm conditional fields pattern:

1. **Imports:**
   - useForm from react-hook-form
   - zodResolver from @hookform/resolvers/zod
   - useEffect from react
   - telegramSchema, TelegramData, formatTelegram from @/lib/formatters/telegram
   - FormFieldSet from ../FormFieldSet

2. **Props type:**
   ```typescript
   type Props = {
     onDataChange: (data: string) => void;
     initialValue?: { mode?: 'username' | 'phone' | 'bot'; username?: string; phoneNumber?: string; botUsername?: string };
   };
   ```

3. **Form setup with conditional defaults:**
   - When mode changes, reset the appropriate field to empty
   - Default mode: 'username'
   ```typescript
   const { control, watch, setValue, reset } = useForm({
     resolver: zodResolver(telegramSchema),
     mode: 'onChange',
     defaultValues: {
       mode: initialValue?.mode || 'username',
       username: initialValue?.username || '',
       phoneNumber: initialValue?.phoneNumber || '',
       botUsername: initialValue?.botUsername || '',
     },
   });

   const mode = watch('mode');
   ```

4. **Handle mode changes (reset fields when mode changes):**
   ```typescript
   useEffect(() => {
     // When mode changes, the irrelevant fields don't matter for validation
     // due to discriminated union, but we should clear them for cleanliness
   }, [mode]);
   ```

5. **QR update effect:**
   ```typescript
   const formData = watch();
   useEffect(() => {
     const result = telegramSchema.safeParse(formData);
     if (result.success) {
       onDataChange(formatTelegram(result.data));
     } else {
       onDataChange('');
     }
   }, [formData, onDataChange]);
   ```

6. **Form fields:**

   **Mode selector (always visible):**
   - select with options: Username, Phone Number, Bot
   - Label: "Link Type"

   **Conditional fields based on mode:**

   **When mode === 'username':**
   - username: text input
   - placeholder: "@username or username"
   - maxLength: 32
   - hint: "5-32 characters. Letters, numbers, underscores. @ will be auto-removed."

   **When mode === 'phone':**
   - phoneNumber: tel input
   - placeholder: "+12025550172"
   - hint: "Enter phone number with country code (E.164 format)"

   **When mode === 'bot':**
   - botUsername: text input
   - placeholder: "@mybotname or mybotname"
   - maxLength: 32
   - hint: "Must end with 'bot' or '_bot'. @ will be auto-removed."

7. **Styling:**
   - Match WiFiForm styling (space-y-4, select/input classes)
   - Hint text in muted/secondary color below inputs
  </action>
  <verify>
   - `npx tsc --noEmit` passes
   - `npm run build` succeeds
   - Form renders mode selector and shows/hides fields correctly
  </verify>
  <done>TelegramForm renders mode selector with three options, shows appropriate field for selected mode, validation feedback displays correctly, @ stripping works transparently</done>
</task>

<task type="auto">
  <name>Task 3: Register Telegram Type in System</name>
  <files>lib/formatters/index.ts, components/forms/qr-forms/index.ts, lib/registry.ts, components/TypeSelector.tsx</files>
  <action>
1. **Update lib/formatters/index.ts:**
   Add export line:
   ```typescript
   // Telegram type
   export { telegramSchema, type TelegramData, formatTelegram } from './telegram';
   ```

   Add 'telegram' to QR_TYPES array:
   ```typescript
   export const QR_TYPES = ['url', 'text', 'email', 'whatsapp', 'wifi', 'vcard', 'telegram'] as const;
   ```

   **Note:** If Plan 07-01 hasn't run yet, add both 'vcard' and 'telegram'. If it has, just add 'telegram'.

2. **Update components/forms/qr-forms/index.ts:**
   Add export:
   ```typescript
   export { TelegramForm } from './TelegramForm';
   ```

3. **Update lib/registry.ts:**
   Add import:
   ```typescript
   import { TelegramForm } from '@/components/forms/qr-forms/TelegramForm';
   ```

   Add to qrFormRegistry:
   ```typescript
   telegram: TelegramForm,
   ```

4. **Update components/TypeSelector.tsx:**
   Add label entry to typeLabels:
   ```typescript
   telegram: 'Telegram',
   ```
  </action>
  <verify>
   - `npx tsc --noEmit` passes (type system includes telegram)
   - `npm run build` succeeds
   - App runs: Telegram appears in type dropdown, form renders when selected, QR preview shows t.me URL
  </verify>
  <done>Telegram type fully registered: appears in type selector, form loads when selected, valid Telegram data generates QR preview with correct t.me URL</done>
</task>

</tasks>

<verification>
## Overall Plan Verification

1. **Schema modes working:**
   - Username: `{ mode: 'username', username: '@testuser' }` parses to `{ mode: 'username', username: 'testuser' }`
   - Phone: `{ mode: 'phone', phoneNumber: '+12025550172' }` valid
   - Bot: `{ mode: 'bot', botUsername: 'helperbot' }` valid
   - Bot without suffix: `{ mode: 'bot', botUsername: 'helper' }` FAILS (must end in bot)

2. **URL formatting:**
   - Username: `https://t.me/testuser`
   - Phone: `https://t.me/+12025550172` (note + is preserved)
   - Bot: `https://t.me/helperbot`

3. **Form integration:**
   - Select Telegram from type dropdown
   - Mode defaults to Username
   - Change mode to Phone - field changes to phone input
   - Change mode to Bot - field changes to bot input
   - Enter valid data in each mode - QR preview updates

4. **@ stripping verification:**
   - Enter "@testuser" in username field
   - Validation passes (@ stripped before 5-char minimum check)
   - Generated URL is `https://t.me/testuser` (no @)

5. **Error states:**
   - Username with <5 chars shows error
   - Username with invalid chars (spaces, special) shows error
   - Bot without "bot" suffix shows error
   - Phone without + prefix shows error
</verification>

<success_criteria>
- [ ] telegramSchema validates three modes with discriminated union
- [ ] @ symbol auto-stripped via .transform() before validation
- [ ] formatTelegram generates correct t.me URLs for each mode
- [ ] Phone mode preserves + prefix in URL (t.me/+number)
- [ ] Bot mode enforces "bot" or "_bot" suffix
- [ ] TelegramForm renders mode selector with three options
- [ ] Conditional fields show/hide based on selected mode
- [ ] Validation errors display correctly per mode
- [ ] Telegram type appears in type selector dropdown
- [ ] Selecting Telegram loads TelegramForm component
- [ ] Valid Telegram data generates QR code preview
- [ ] Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-complex-qr-types/07-02-SUMMARY.md`
</output>
