---
phase: 05-form-system-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - lib/types/qr-config.ts
  - lib/formatters/url.ts
  - lib/formatters/text.ts
  - lib/formatters/email.ts
  - lib/formatters/index.ts
autonomous: true

must_haves:
  truths:
    - "React Hook Form and Zod are installed and importable"
    - "QRType union includes all v1.0 types (url, text, email)"
    - "Each QR type has a Zod schema that validates its inputs"
    - "Each schema infers TypeScript types matching its validation rules"
  artifacts:
    - path: "lib/formatters/url.ts"
      provides: "URL schema and formatter"
      exports: ["urlSchema", "UrlData", "formatUrl"]
    - path: "lib/formatters/text.ts"
      provides: "Text schema and formatter"
      exports: ["textSchema", "TextData", "formatText"]
    - path: "lib/formatters/email.ts"
      provides: "Email schema and formatter"
      exports: ["emailSchema", "EmailData", "formatEmail"]
    - path: "lib/formatters/index.ts"
      provides: "Barrel export for all formatters"
      exports: ["urlSchema", "textSchema", "emailSchema"]
  key_links:
    - from: "lib/formatters/email.ts"
      to: "lib/utils/mailto-formatter.ts"
      via: "import formatMailto"
      pattern: "import.*formatMailto.*from.*mailto-formatter"
---

<objective>
Install React Hook Form + Zod dependencies and create co-located schema/formatter files for existing QR types.

Purpose: Establish the validation foundation that all future QR types will build upon. The co-located schema + formatter pattern ensures type safety flows from validation through formatting.

Output: Dependencies installed, Zod schemas for url/text/email types with inferred TypeScript types, formatter functions co-located with schemas.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-form-system-foundation/05-RESEARCH.md

# Current implementation references
@lib/types/qr-config.ts
@lib/utils/validation.ts
@lib/utils/mailto-formatter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install React Hook Form + Zod dependencies</name>
  <files>package.json</files>
  <action>
Install the form validation stack using yarn:

```bash
yarn add react-hook-form zod @hookform/resolvers
```

Per research: react-hook-form 7.71.1+, zod 4.3.5+, @hookform/resolvers 3.9.1+

Do NOT install vcards-js, ics, or @icons-pack/react-simple-icons yet - those are for Phase 6+.
  </action>
  <verify>
```bash
# Check packages are in dependencies
grep -E "react-hook-form|zod|@hookform/resolvers" package.json
```
  </verify>
  <done>package.json shows react-hook-form, zod, and @hookform/resolvers in dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create Zod schemas with co-located formatters for existing QR types</name>
  <files>
lib/formatters/url.ts
lib/formatters/text.ts
lib/formatters/email.ts
lib/formatters/index.ts
  </files>
  <action>
Create lib/formatters/ directory and files following the co-located schema + formatter pattern from research.

**lib/formatters/url.ts:**
```typescript
import { z } from 'zod';

// Schema with validation
export const urlSchema = z.object({
  url: z.string()
    .min(1, 'URL is required')
    .refine(
      (val) => {
        try {
          const url = new URL(val);
          return url.protocol === 'http:' || url.protocol === 'https:';
        } catch {
          return false;
        }
      },
      { message: 'Must be a valid URL starting with http:// or https://' }
    ),
});

// Infer TypeScript type from schema
export type UrlData = z.infer<typeof urlSchema>;

// Formatter is identity for URL (no transformation needed)
export function formatUrl(data: UrlData): string {
  return data.url;
}
```

**lib/formatters/text.ts:**
```typescript
import { z } from 'zod';

export const textSchema = z.object({
  text: z.string()
    .min(1, 'Text is required')
    .max(2000, 'Text must be 2000 characters or less'),
});

export type TextData = z.infer<typeof textSchema>;

// Formatter is identity for text (no transformation needed)
export function formatText(data: TextData): string {
  return data.text;
}
```

**lib/formatters/email.ts:**
```typescript
import { z } from 'zod';
import { formatMailto } from '@/lib/utils/mailto-formatter';

export const emailSchema = z.object({
  to: z.string()
    .min(1, 'Email address is required')
    .email('Must be a valid email address'),
  subject: z.string()
    .max(200, 'Subject must be 200 characters or less')
    .optional()
    .transform((val) => val || ''),
  body: z.string()
    .max(1000, 'Body must be 1000 characters or less')
    .optional()
    .transform((val) => val || ''),
});

export type EmailData = z.infer<typeof emailSchema>;

// Formatter uses existing mailto-formatter
export function formatEmail(data: EmailData): string {
  return formatMailto({
    to: data.to,
    subject: data.subject || undefined,
    body: data.body || undefined,
  });
}
```

**lib/formatters/index.ts:**
```typescript
// URL type
export { urlSchema, type UrlData, formatUrl } from './url';

// Text type
export { textSchema, type TextData, formatText } from './text';

// Email type
export { emailSchema, type EmailData, formatEmail } from './email';

// QR type keys for registry (v1.0 types)
export const QR_TYPES = ['url', 'text', 'email'] as const;
export type QRTypeKey = typeof QR_TYPES[number];
```

Note: The email formatter re-uses the existing formatMailto function to avoid duplication. This establishes the pattern of formatters calling existing utilities when appropriate.
  </action>
  <verify>
```bash
# Check files exist with expected exports
grep -l "export.*Schema" lib/formatters/*.ts
grep -l "export.*format" lib/formatters/*.ts
grep -l "z.infer" lib/formatters/*.ts

# TypeScript compilation check
npx tsc --noEmit lib/formatters/*.ts 2>&1 | head -20
```
  </verify>
  <done>
- lib/formatters/url.ts exports urlSchema, UrlData type, formatUrl function
- lib/formatters/text.ts exports textSchema, TextData type, formatText function
- lib/formatters/email.ts exports emailSchema, EmailData type, formatEmail function
- lib/formatters/index.ts barrel exports all schemas, types, formatters, and QR_TYPES constant
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Update QRType in types/qr-config.ts to use shared constant</name>
  <files>lib/types/qr-config.ts</files>
  <action>
Update the QRType definition to derive from the QR_TYPES constant for single source of truth.

Replace:
```typescript
export type QRType = 'url' | 'text' | 'email';
```

With:
```typescript
import { QRTypeKey } from '@/lib/formatters';

// QRType derived from formatters module (single source of truth)
export type QRType = QRTypeKey;
```

Keep the existing EmailData interface for backward compatibility with current DataInput component (it will be deprecated in Plan 02 when we migrate to RHF forms).

Add a comment noting the old EmailData interface:
```typescript
/**
 * @deprecated Use EmailData from lib/formatters/email instead
 * Kept for backward compatibility during Phase 5 migration
 */
export interface EmailData {
  to: string;
  subject?: string;
  body?: string;
}
```
  </action>
  <verify>
```bash
# Check import and type definition
grep -A2 "import.*QRTypeKey" lib/types/qr-config.ts
grep "export type QRType" lib/types/qr-config.ts

# Ensure app still compiles
yarn build 2>&1 | tail -10
```
  </verify>
  <done>
- QRType is now derived from QRTypeKey (single source of truth)
- Old EmailData interface marked as deprecated
- Application builds without errors
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Dependencies installed:
```bash
yarn list react-hook-form zod @hookform/resolvers
```

2. Schema files exist with correct exports:
```bash
ls -la lib/formatters/
```

3. Full build succeeds:
```bash
yarn build
```

4. Tests still pass:
```bash
yarn test:run
```
</verification>

<success_criteria>
- react-hook-form, zod, @hookform/resolvers in package.json dependencies
- lib/formatters/ directory contains url.ts, text.ts, email.ts, index.ts
- Each formatter file exports schema, inferred type, and format function
- QRType in types/qr-config.ts derives from QRTypeKey
- yarn build succeeds
- yarn test:run passes (existing tests unaffected)
</success_criteria>

<output>
After completion, create `.planning/phases/05-form-system-foundation/05-01-SUMMARY.md`
</output>
