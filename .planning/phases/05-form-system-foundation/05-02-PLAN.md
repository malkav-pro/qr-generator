---
phase: 05-form-system-foundation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - components/forms/FormFieldSet.tsx
  - components/forms/qr-forms/UrlForm.tsx
  - components/forms/qr-forms/TextForm.tsx
  - components/forms/qr-forms/EmailForm.tsx
  - components/forms/qr-forms/index.ts
  - components/forms/index.ts
  - lib/registry.ts
  - components/TypeSelector.tsx
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - "FormFieldSet renders label, input via render prop, and validation errors"
    - "Each QR type form uses useForm with zodResolver for validation"
    - "Component registry returns correct form component for each QR type"
    - "TypeSelector uses QR_TYPES constant instead of hardcoded array"
    - "User can select URL/text/email type and see appropriate form"
    - "Form validation errors display on blur (mode: 'onBlur')"
    - "QR code updates when form data changes"
  artifacts:
    - path: "components/forms/FormFieldSet.tsx"
      provides: "Reusable form field wrapper with Controller integration"
      exports: ["FormFieldSet"]
    - path: "components/forms/qr-forms/UrlForm.tsx"
      provides: "URL type form with RHF + Zod"
      exports: ["UrlForm"]
    - path: "components/forms/qr-forms/TextForm.tsx"
      provides: "Text type form with RHF + Zod"
      exports: ["TextForm"]
    - path: "components/forms/qr-forms/EmailForm.tsx"
      provides: "Email type form with RHF + Zod"
      exports: ["EmailForm"]
    - path: "lib/registry.ts"
      provides: "QR type to form component mapping"
      exports: ["qrFormRegistry", "getQRForm"]
  key_links:
    - from: "lib/registry.ts"
      to: "components/forms/qr-forms/*"
      via: "dynamic import mapping"
      pattern: "qrFormRegistry.*UrlForm|TextForm|EmailForm"
    - from: "app/page.tsx"
      to: "lib/registry.ts"
      via: "getQRForm call"
      pattern: "getQRForm\\(qrType\\)"
    - from: "components/forms/qr-forms/UrlForm.tsx"
      to: "lib/formatters/url.ts"
      via: "schema + formatter import"
      pattern: "import.*urlSchema.*formatUrl.*from.*formatters"
---

<objective>
Create FormFieldSet component, type-specific form components, and component registry. Migrate existing DataInput to the new React Hook Form-based architecture.

Purpose: Replace the current if/else branching in DataInput with a registry-based pattern that scales to 5+ new QR types without modification. Forms use Controller pattern for consistent validation UX.

Output: Working form system where selecting a QR type renders the appropriate form component with full validation, and QR preview updates in real-time.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-form-system-foundation/05-RESEARCH.md
@.planning/phases/05-form-system-foundation/05-01-SUMMARY.md

# Schemas and formatters from Plan 01
@lib/formatters/index.ts
@lib/formatters/url.ts
@lib/formatters/text.ts
@lib/formatters/email.ts

# Current implementation to migrate
@components/DataInput.tsx
@components/TypeSelector.tsx
@app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FormFieldSet component with Controller integration</name>
  <files>
components/forms/FormFieldSet.tsx
components/forms/index.ts
  </files>
  <action>
Create components/forms/ directory and FormFieldSet component following the pattern from research.

**components/forms/FormFieldSet.tsx:**
```typescript
import { Control, Controller, FieldPath, FieldValues, FieldError } from 'react-hook-form';
import { ReactNode } from 'react';

type FormFieldSetProps<T extends FieldValues> = {
  control: Control<T>;
  name: FieldPath<T>;
  label: string;
  optional?: boolean;
  render: (field: {
    value: any;
    onChange: (value: any) => void;
    onBlur: () => void;
    name: string;
    ref: React.Ref<any>;
  }, fieldState: {
    invalid: boolean;
    isTouched: boolean;
    isDirty: boolean;
    error?: FieldError;
  }) => ReactNode;
};

export function FormFieldSet<T extends FieldValues>({
  control,
  name,
  label,
  optional = false,
  render,
}: FormFieldSetProps<T>) {
  return (
    <Controller
      control={control}
      name={name}
      render={({ field, fieldState }) => (
        <div className="space-y-2.5">
          <label
            htmlFor={name}
            className="block text-xs font-bold uppercase tracking-wider text-[var(--text-secondary)]"
          >
            {label}
            {!optional && <span className="text-red-400 ml-1">*</span>}
            {optional && (
              <span className="text-[var(--text-muted)] text-xs normal-case ml-1">(optional)</span>
            )}
          </label>
          {render(field, fieldState)}
          {fieldState.error && (
            <p
              className="text-xs text-red-400 font-medium"
              role="alert"
              aria-live="polite"
            >
              {fieldState.error.message}
            </p>
          )}
        </div>
      )}
    />
  );
}
```

**components/forms/index.ts:**
```typescript
export { FormFieldSet } from './FormFieldSet';
```

Key points:
- Uses Controller for consistent validation handling
- Label styling matches existing DataInput patterns (text-xs, uppercase, tracking-wider)
- Error display uses red-400 (matching existing ContrastWarning pattern)
- ARIA attributes for accessibility (role="alert", aria-live="polite")
- Optional prop controls required indicator display
  </action>
  <verify>
```bash
# Check file exists and exports FormFieldSet
grep "export.*FormFieldSet" components/forms/FormFieldSet.tsx
grep "export.*FormFieldSet" components/forms/index.ts

# TypeScript check
npx tsc --noEmit components/forms/FormFieldSet.tsx 2>&1 | head -10
```
  </verify>
  <done>
- components/forms/FormFieldSet.tsx exports FormFieldSet component
- Component accepts generic type parameter for type-safe field paths
- Label, error display, and accessibility attributes implemented
  </done>
</task>

<task type="auto">
  <name>Task 2: Create type-specific form components and registry</name>
  <files>
components/forms/qr-forms/UrlForm.tsx
components/forms/qr-forms/TextForm.tsx
components/forms/qr-forms/EmailForm.tsx
components/forms/qr-forms/index.ts
lib/registry.ts
  </files>
  <action>
Create form components for each QR type and the registry that maps types to components.

**components/forms/qr-forms/UrlForm.tsx:**
```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { useEffect } from 'react';
import { urlSchema, UrlData, formatUrl } from '@/lib/formatters';
import { FormFieldSet } from '../FormFieldSet';

type Props = {
  onDataChange: (data: string) => void;
  initialValue?: string;
};

export function UrlForm({ onDataChange, initialValue }: Props) {
  const { control, watch } = useForm<UrlData>({
    resolver: zodResolver(urlSchema),
    mode: 'onBlur',
    defaultValues: {
      url: initialValue || '',
    },
  });

  // Watch for changes and update parent
  const formData = watch();

  useEffect(() => {
    // Only format and send if there's data
    if (formData.url) {
      try {
        // Attempt to format (validates implicitly)
        const formatted = formatUrl({ url: formData.url });
        onDataChange(formatted);
      } catch {
        // Invalid data, send raw value for preview
        onDataChange(formData.url);
      }
    } else {
      onDataChange('');
    }
  }, [formData, onDataChange]);

  return (
    <FormFieldSet
      control={control}
      name="url"
      label="URL"
      render={(field) => (
        <input
          {...field}
          id="url"
          type="text"
          placeholder="https://example.com"
          className="w-full px-3.5 py-2.5 h-11 border rounded-lg
            transition-all duration-200
            focus:outline-none"
        />
      )}
    />
  );
}
```

**components/forms/qr-forms/TextForm.tsx:**
```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { useEffect } from 'react';
import { textSchema, TextData, formatText } from '@/lib/formatters';
import { FormFieldSet } from '../FormFieldSet';

type Props = {
  onDataChange: (data: string) => void;
  initialValue?: string;
};

export function TextForm({ onDataChange, initialValue }: Props) {
  const { control, watch } = useForm<TextData>({
    resolver: zodResolver(textSchema),
    mode: 'onBlur',
    defaultValues: {
      text: initialValue || '',
    },
  });

  const formData = watch();

  useEffect(() => {
    if (formData.text) {
      const formatted = formatText({ text: formData.text });
      onDataChange(formatted);
    } else {
      onDataChange('');
    }
  }, [formData, onDataChange]);

  return (
    <FormFieldSet
      control={control}
      name="text"
      label="Text"
      render={(field) => (
        <textarea
          {...field}
          id="text"
          placeholder="Enter any text..."
          rows={4}
          className="w-full px-3.5 py-2.5 border rounded-lg resize-none
            transition-all duration-200
            focus:outline-none"
        />
      )}
    />
  );
}
```

**components/forms/qr-forms/EmailForm.tsx:**
```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { useEffect } from 'react';
import { emailSchema, EmailData, formatEmail } from '@/lib/formatters';
import { FormFieldSet } from '../FormFieldSet';

type Props = {
  onDataChange: (data: string) => void;
  initialValue?: { to?: string; subject?: string; body?: string };
};

export function EmailForm({ onDataChange, initialValue }: Props) {
  const { control, watch } = useForm<EmailData>({
    resolver: zodResolver(emailSchema),
    mode: 'onBlur',
    defaultValues: {
      to: initialValue?.to || '',
      subject: initialValue?.subject || '',
      body: initialValue?.body || '',
    },
  });

  const formData = watch();

  useEffect(() => {
    if (formData.to) {
      try {
        const formatted = formatEmail(formData);
        onDataChange(formatted);
      } catch {
        // Invalid data, send raw mailto
        onDataChange(`mailto:${formData.to}`);
      }
    } else {
      onDataChange('');
    }
  }, [formData, onDataChange]);

  return (
    <div className="space-y-4">
      <FormFieldSet
        control={control}
        name="to"
        label="To"
        render={(field) => (
          <input
            {...field}
            id="to"
            type="email"
            placeholder="recipient@example.com"
            className="w-full px-3.5 py-2.5 h-11 border rounded-lg
              transition-all duration-200
              focus:outline-none"
          />
        )}
      />

      <FormFieldSet
        control={control}
        name="subject"
        label="Subject"
        optional
        render={(field) => (
          <input
            {...field}
            id="subject"
            type="text"
            placeholder="Email subject"
            className="w-full px-3.5 py-2.5 h-11 border rounded-lg
              transition-all duration-200
              focus:outline-none"
          />
        )}
      />

      <FormFieldSet
        control={control}
        name="body"
        label="Body"
        optional
        render={(field) => (
          <textarea
            {...field}
            id="body"
            placeholder="Email body"
            rows={4}
            className="w-full px-3.5 py-2.5 border rounded-lg resize-none
              transition-all duration-200
              focus:outline-none"
          />
        )}
      />
    </div>
  );
}
```

**components/forms/qr-forms/index.ts:**
```typescript
export { UrlForm } from './UrlForm';
export { TextForm } from './TextForm';
export { EmailForm } from './EmailForm';
```

**lib/registry.ts:**
```typescript
import { ComponentType } from 'react';
import { UrlForm } from '@/components/forms/qr-forms/UrlForm';
import { TextForm } from '@/components/forms/qr-forms/TextForm';
import { EmailForm } from '@/components/forms/qr-forms/EmailForm';
import { QRTypeKey } from './formatters';

// Common props all QR form components accept
export type QRFormProps = {
  onDataChange: (data: string) => void;
  initialValue?: any;
};

// Registry mapping QR type keys to form components
export const qrFormRegistry: Record<QRTypeKey, ComponentType<QRFormProps>> = {
  url: UrlForm,
  text: TextForm,
  email: EmailForm,
};

// Get form component for a QR type (type-safe lookup)
export function getQRForm(type: QRTypeKey): ComponentType<QRFormProps> {
  return qrFormRegistry[type];
}
```

Key points:
- All forms use mode: 'onBlur' per research (prevents premature validation)
- Forms watch for changes and call onDataChange for real-time QR updates
- Input styling matches existing DataInput patterns exactly
- Registry is type-safe using QRTypeKey from formatters
- EmailForm handles all 3 fields with appropriate optional flags
  </action>
  <verify>
```bash
# Check all form files exist
ls -la components/forms/qr-forms/

# Check registry exports
grep "export.*qrFormRegistry\|getQRForm" lib/registry.ts

# TypeScript check on registry
npx tsc --noEmit lib/registry.ts 2>&1 | head -10
```
  </verify>
  <done>
- UrlForm, TextForm, EmailForm components created with RHF + Zod
- lib/registry.ts exports qrFormRegistry and getQRForm
- All components use mode: 'onBlur' validation
- Form styling matches existing DataInput patterns
  </done>
</task>

<task type="auto">
  <name>Task 3: Migrate TypeSelector and page.tsx to use registry pattern</name>
  <files>
components/TypeSelector.tsx
app/page.tsx
components/index.ts
  </files>
  <action>
Update TypeSelector to use QR_TYPES constant and migrate page.tsx to use the registry.

**components/TypeSelector.tsx** - Update to use QR_TYPES:
```typescript
import { QR_TYPES, type QRTypeKey } from '@/lib/formatters';

interface TypeSelectorProps {
  value: QRTypeKey;
  onChange: (type: QRTypeKey) => void;
}

// Human-readable labels for QR types
const typeLabels: Record<QRTypeKey, string> = {
  url: 'URL',
  text: 'Text',
  email: 'Email',
};

export function TypeSelector({ value, onChange }: TypeSelectorProps) {
  return (
    <div className="space-y-2.5">
      <label className="block text-xs font-bold uppercase tracking-wider text-[var(--text-secondary)]">
        QR Code Type
      </label>
      <div className="flex gap-2" role="tablist">
        {QR_TYPES.map((type) => (
          <button
            key={type}
            type="button"
            role="tab"
            aria-label={`Select ${typeLabels[type]} type`}
            aria-selected={value === type}
            onClick={() => onChange(type)}
            className={`relative px-5 py-2.5 rounded-lg font-semibold text-sm tracking-tight transition-all duration-300
              focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--accent-start)] focus-visible:ring-offset-2 focus-visible:ring-offset-[var(--surface-raised)]
              ${
              value === type
                ? 'bg-gradient-to-r from-[var(--accent-start)] to-[var(--accent-end)] text-[var(--background)] shadow-[0_0_20px_var(--accent-glow)]'
                : 'bg-[var(--surface-elevated)] text-[var(--text-secondary)] hover:bg-[var(--surface-base)] hover:text-[var(--text-primary)] border border-[var(--border-medium)]'
            }`}
          >
            {typeLabels[type]}
          </button>
        ))}
      </div>
    </div>
  );
}
```

**app/page.tsx** - Replace DataInput with registry-based form:

Key changes:
1. Import getQRForm from registry
2. Replace DataInput import with dynamic form rendering
3. Remove emailData state (handled internally by EmailForm)
4. Simplify handleDataChange

The updated page.tsx should:
- Import: `import { getQRForm } from '@/lib/registry';`
- Import: `import { type QRTypeKey } from '@/lib/formatters';`
- Change qrType state type: `useState<QRTypeKey>('url')`
- Remove: `const [emailData, setEmailData] = useState<EmailData>({ to: '' });`
- Remove: `handleEmailChange` callback
- Replace DataInput component with:
```tsx
{(() => {
  const FormComponent = getQRForm(qrType);
  return (
    <FormComponent
      onDataChange={handleDataChange}
      initialValue={data}
    />
  );
})()}
```

Also update handleTypeChange to just clear data:
```typescript
const handleTypeChange = useCallback((newType: QRTypeKey) => {
  setQrType(newType);
  setData('');
}, []);
```

Update QRConfig type import to use QRTypeKey for consistency.

**components/index.ts** - Add form exports:
Add line:
```typescript
export { FormFieldSet } from './forms';
export { UrlForm, TextForm, EmailForm } from './forms/qr-forms';
```
But keep DataInput export for now (deprecated but not removed yet).
  </action>
  <verify>
```bash
# Check TypeSelector uses QR_TYPES
grep "QR_TYPES" components/TypeSelector.tsx

# Check page.tsx uses registry
grep "getQRForm" app/page.tsx

# Build check
yarn build 2>&1 | tail -20

# Run dev server and manually test (human verification optional)
# yarn dev
```
  </verify>
  <done>
- TypeSelector uses QR_TYPES constant from formatters
- page.tsx uses getQRForm from registry
- emailData state removed (handled by EmailForm internally)
- Application builds and runs correctly
- Selecting URL/text/email type shows appropriate form with validation
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build succeeds:
```bash
yarn build
```

2. Tests pass:
```bash
yarn test:run
```

3. Manual verification (start dev server):
```bash
yarn dev
```
Then verify:
- Select URL type: see URL input, validation error on blur if invalid URL
- Select Text type: see textarea, no validation error unless empty on submit
- Select Email type: see 3 fields, validation on blur
- Enter valid data in each: QR code preview updates
- Clear field: QR preview updates/clears

4. Component tree check:
- TypeSelector -> uses QR_TYPES constant
- page.tsx -> calls getQRForm(qrType)
- Each form -> uses FormFieldSet with Controller
</verification>

<success_criteria>
- FormFieldSet component renders labels, inputs, and errors consistently
- UrlForm, TextForm, EmailForm use RHF + Zod with mode: 'onBlur'
- Registry returns correct component for each QR type
- TypeSelector iterates QR_TYPES instead of hardcoded array
- page.tsx uses registry pattern, not if/else branching
- All existing functionality preserved (type switching, QR generation, URL state)
- yarn build succeeds
- yarn test:run passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-form-system-foundation/05-02-SUMMARY.md`
</output>
